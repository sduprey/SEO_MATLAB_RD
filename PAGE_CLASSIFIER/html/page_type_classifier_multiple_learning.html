
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Machine Learning for e-commerce web page page type classification</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-01-05"><meta name="DC.source" content="page_type_classifier_multiple_learning.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Machine Learning for e-commerce web page page type classification</h1><!--introduction--><p>Implementing and comparing different machine learning techniques to choose the best approach can be challenging. Machine learning is synonymous with <b>Non-parametric</b> modeling techniques. The term non-parametric is not meant to imply that such models completely lack parameters but that the number and nature of the parameters are flexible and determined from data.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Loading data</a></li><li><a href="#2">Cross Validation</a></li><li><a href="#3">Tree performance on validating and training set</a></li><li><a href="#4">Neural Networks</a></li><li><a href="#5">Generalized Linear Model - Logistic Regression</a></li><li><a href="#6">Discriminant Analysis</a></li><li><a href="#7">Classification Using Nearest Neighbors</a></li><li><a href="#8">Naive Bayes Classification</a></li><li><a href="#9">Support Vector Machines</a></li><li><a href="#10">Decision Trees</a></li><li><a href="#11">Ensemble Learning: TreeBagger</a></li><li><a href="#12">Simplify Model - Optional</a></li><li><a href="#13">Estimating a Good Ensemble Size : learning curve</a></li><li><a href="#14">Estimating Feature Importance</a></li><li><a href="#15">Sequential Feature Selection</a></li><li><a href="#16">TreeBagger with Reduced Feature Set</a></li><li><a href="#17">Compare Results</a></li><li><a href="#18">Shut Down Workers</a></li></ul></div><h2>Loading data<a name="1"></a></h2><pre class="codeinput">load(<span class="string">'shallow_crawl_cdiscount.mat'</span>);
disp(catPred);
</pre><pre class="codeoutput">  Columns 1 through 4

    'depth'    'outlinks_size'    'inlinks_size'    'nb_breadcrumbs'

  Columns 5 through 7

    'nb_aggregated_ra...'    'nb_ratings_values'    'nb_prices'

  Columns 8 through 11

    'nb_availabilities'    'nb_reviews'    'nb_reviews_count'    'nb_images'

</pre><h2>Cross Validation<a name="2"></a></h2><p>Cross validation is almost an inherent part of machine learning. Cross validation may be used to compare the performance of different predictive modeling techniques. In this example, we use holdout validation. Other techniques including k-fold and leave-one-out cross validation are also available.</p><p>In this example, we partition the data into training set and test set. The training set will be used to calibrate/train the model parameters. The trained model is then used to make a prediction on the test set. Predicted values will be compared with actual data to compute the confusion matrix. Confusion matrix is one way to visualize the performance of a machine learning technique.</p><pre class="codeinput"><span class="comment">% In this example, we will hold 40% of the data, selected randomly, for</span>
<span class="comment">% test phase.</span>
cv = cvpartition(length(Y),<span class="string">'holdout'</span>,0.40);

<span class="comment">% Training set</span>
Xtrain = X(training(cv),:);
Ytrain = Y(training(cv),:);
<span class="comment">% Test set</span>
Xtest = X(test(cv),:);
Ytest = Y(test(cv),:);

disp(<span class="string">'Training Set'</span>)
tabulate(Ytrain)
disp(<span class="string">'Test Set'</span>)
tabulate(Ytest)
</pre><pre class="codeoutput">Training Set
               Value    Count   Percent
        FicheProduit    13308     45.71%
        ListeProduit     5070     17.41%
  ListeProduitFiltre     3157     10.84%
         PageConcept        4      0.01%
          PageMarque     3317     11.39%
        SearchDexing     2738      9.40%
             Unknown     1110      3.81%
             Vitrine      409      1.40%
Test Set
               Value    Count   Percent
        FicheProduit     8844     45.57%
        ListeProduit     3448     17.77%
  ListeProduitFiltre     2042     10.52%
         PageConcept        2      0.01%
          PageMarque     2222     11.45%
        SearchDexing     1818      9.37%
             Unknown      774      3.99%
             Vitrine      258      1.33%
</pre><h2>Tree performance on validating and training set<a name="3"></a></h2><pre class="codeinput">t = classregtree(Xtrain,Ytrain);
<span class="comment">%  See tree</span>
view(t)
<span class="comment">% How well did the single tree perform on the training set</span>
<span class="comment">% very well but overfit the noise</span>
predY = t(Xtrain);
<span class="comment">%predY = round(predY);</span>
disp(<span class="string">'Full tree training set'</span>)
disp(<span class="string">'Full tree training set'</span>)
myCategoricalErrorRate(predY,Ytrain);
C_tree = confusionmat(categorical(predY),categorical(Ytrain));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_tree = bsxfun(@rdivide,C_tree,sum(C_tree,2)) * 100 <span class="comment">%#ok&lt;*NOPTS&gt;</span>

<span class="comment">% Calculate the single tree's predictions on the validating set...</span>
predY = t(Xtest);
disp(<span class="string">'Full tree validating set'</span>)
myCategoricalErrorRate(predY,Ytest);
[C_tree, order] = confusionmat(categorical(predY),categorical(Ytest));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_tree = bsxfun(@rdivide,C_tree,sum(C_tree,2)) * 100 <span class="comment">%#ok&lt;*NOPTS&gt;</span>
order
</pre><pre class="codeoutput">Full tree training set
Full tree training set
Tree, % Good classified rate on set  : 95.7098

C_tree =

  Columns 1 through 7

   99.8424    0.1576         0         0         0         0         0
    0.0195   90.5022    3.4786         0    4.0258         0    0.2931
         0    5.5098   94.3319         0         0         0         0
         0         0         0  100.0000         0         0         0
         0    5.9090         0    0.0603   89.2674    3.8589    0.2412
         0    0.2534         0    0.0362    5.1774   94.4967    0.0362
         0    0.2757         0         0         0         0   99.4485
         0   11.1111         0         0    2.0468         0    1.1696

  Column 8

         0
    1.6807
    0.1583
         0
    0.6632
         0
    0.2757
   85.6725

Full tree validating set
Tree, % Good classified rate on set  : 92.1167

C_tree =

  Columns 1 through 7

   99.8081    0.1919         0         0         0         0         0
    0.0579   82.5760    6.6570         0    7.7279         0    0.2315
         0   12.2222   87.4396         0         0         0    0.1932
         0         0         0         0         0         0  100.0000
         0   10.9850    0.0454         0   82.1607    5.6741    0.4993
         0    0.1642         0    0.1095    6.7871   92.5561    0.1642
         0    0.1332         0         0         0    0.2663   98.4021
         0   32.9167    0.4167         0    8.7500         0    2.5000

  Column 8

         0
    2.7496
    0.1449
         0
    0.6355
    0.2189
    1.1984
   55.4167


order = 

     FicheProduit 
     ListeProduit 
     ListeProduitFiltre 
     PageConcept 
     PageMarque 
     SearchDexing 
     Unknown 
     Vitrine 

</pre><img vspace="5" hspace="5" src="page_type_classifier_multiple_learning_01.png" alt=""> <h2>Neural Networks<a name="4"></a></h2><p>Neural Network Toolbox supports supervised learning with feedforward, radial basis, and dynamic networks. It supports both classification and regression algorithms. It also supports unsupervised learning with self-organizing maps and competitive layers.</p><p>One can make use of the interactive tools to setup, train and validate a neural network. It is then possible to auto-generate the code for the purpose of automation. In this example, the auto-generated code has been updated to utilize a pool of workers, if available. This is achieved by simply setting the <i>useParallel</i> flag while making a call to <tt>train</tt>.</p><pre class="language-matlab">[net,~] = train(net,inputs,targets,<span class="string">'useParallel'</span>,<span class="string">'yes'</span>);
</pre><p>If a GPU is available, it may be utilized by setting the <i>useGPU</i> flag.</p><p>The trained network is used to make a prediction on the test data and confusion matrix is generated for comparison with other techniques.</p><pre class="codeinput"><span class="comment">% Use modified autogenerated code to train the network</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % YN = double(Y)-1;</span>
<span class="comment">% % % % % % XtrainNN = X(training(cv),:);</span>
<span class="comment">% % % % % % YtrainNN = YN(training(cv),:);</span>
<span class="comment">% % % % % % Test set</span>
<span class="comment">% % % % % % XtestNN = X(test(cv),:);</span>
<span class="comment">% % % % % % YtestNN = YN(test(cv),:);</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % [XtrainNN, YtrainNN, XtestNN, YtestNN] = preparedataNN(X, Y, cv);</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % [~, net] = NNfun(XtrainNN,YtrainNN);</span>
<span class="comment">% % % % % % view(net);</span>
<span class="comment">% % % % % % Make a prediction for the test set</span>
<span class="comment">% % % % % % Y_nn = net(Xtest');</span>
<span class="comment">% % % % % % Y_nn = round(Y_nn');</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % Compute the confusion matrix</span>
<span class="comment">% % % % % % C_nn = confusionmat(categorical(Ytest),categorical(Y_nn));</span>
<span class="comment">% % % % % % Examine the confusion matrix for each class as a percentage of the true class</span>
<span class="comment">% % % % % % C_nn = bsxfun(@rdivide,C_nn,sum(C_nn,2)) * 100 %#ok&lt;*NOPTS&gt;</span>
</pre><h2>Generalized Linear Model - Logistic Regression<a name="5"></a></h2><p>In this example, a logistic regression model is leveraged. Response may follow normal, binomial, Poisson, gamma, or inverse Gaussian distribution.</p><p>Since the response in this data set is binary, binomial distribution is suitable.</p><pre class="codeinput"><span class="comment">% Train the classifier</span>
<span class="comment">% % % % % % glm = GeneralizedLinearModel.fit(Xtrain,Ytrain,'linear','Distribution','binomial','link','logit');</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % % Make a prediction for the test set</span>
<span class="comment">% % % % % % Y_glm = glm.predict(Xtest);</span>
<span class="comment">% % % % % % Y_glm = round(Y_glm);</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % % Compute the confusion matrix</span>
<span class="comment">% % % % % % C_glm = confusionmat(categorical(Ytest),categorical(Y_glm));</span>
<span class="comment">% % % % % % % Examine the confusion matrix for each class as a percentage of the true class</span>
<span class="comment">% % % % % % C_glm = bsxfun(@rdivide,C_glm,sum(C_glm,2)) * 100</span>
</pre><h2>Discriminant Analysis<a name="6"></a></h2><p>Discriminant analysis is a classification method. It assumes that different classes generate data based on different Gaussian distributions. Linear discriminant analysis is also known as the Fisher discriminant.</p><p>Here, a quadratic discriminant classifier is used.</p><pre class="codeinput"><span class="comment">% Train the classifier</span>
da = ClassificationDiscriminant.fit(Xtrain,Ytrain,<span class="string">'discrimType'</span>,<span class="string">'pseudoQuadratic'</span>);

<span class="comment">% Make a prediction for the test set</span>
Y_da = da.predict(Xtest);

<span class="comment">% Compute the confusion matrix</span>
C_da = confusionmat(categorical(Ytest),categorical(Y_da));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_da = bsxfun(@rdivide,C_da,sum(C_da,2)) * 100
</pre><pre class="codeoutput">
C_da =

  Columns 1 through 7

   96.4156    0.0791    0.8367         0    1.9222    0.4636         0
    0.4640   99.2749    0.0290         0         0    0.0290         0
         0  100.0000         0         0         0         0         0
         0  100.0000         0         0         0         0         0
         0   99.4599         0    0.0900         0         0    0.4500
         0  100.0000         0         0         0         0         0
         0    5.0388         0    0.2584         0         0   94.4444
         0   94.5736         0         0         0    0.3876    0.3876

  Column 8

    0.2827
    0.2030
         0
         0
         0
         0
    0.2584
    4.6512

</pre><h2>Classification Using Nearest Neighbors<a name="7"></a></h2><p>Categorizing query points based on their distance to points in a training dataset can be a simple yet effective way of classifying new points. Various distance metrics such as euclidean, correlation, hamming, mahalonobis or your own distance metric may be used.</p><pre class="codeinput"><span class="comment">% Train the classifier</span>
knn = ClassificationKNN.fit(Xtrain,Ytrain,<span class="string">'Distance'</span>,<span class="string">'seuclidean'</span>);

<span class="comment">% Make a prediction for the test set</span>
Y_knn = knn.predict(Xtest);

<span class="comment">% Compute the confusion matrix</span>
C_knn = confusionmat(categorical(Ytest),categorical(Y_knn));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_knn = bsxfun(@rdivide,C_knn,sum(C_knn,2)) * 100
</pre><pre class="codeoutput">
C_knn =

  Columns 1 through 7

   99.8417    0.1583         0         0         0         0         0
    0.4640   79.2053    8.0046         0    9.1067    0.1450    0.1160
         0   12.9775   86.9246         0    0.0490         0         0
         0         0         0   50.0000   50.0000         0         0
         0   12.7363         0    0.1350   77.5428    7.5158    0.2700
         0    0.6601         0         0    8.3058   90.9241    0.1100
         0    1.6796    0.1292    0.3876    0.7752    0.2584   95.4780
    0.3876   36.0465    1.9380         0    6.9767    1.5504    1.1628

  Column 8

         0
    2.9582
    0.0490
         0
    1.8002
         0
    1.2920
   51.9380

</pre><h2>Naive Bayes Classification<a name="8"></a></h2><p>Naive Bayes classification is based on estimating P(X|Y), the probability or probability density of features X given class Y. The Naive Bayes classification object provides support for normal (Gaussian), kernel, multinomial, and multivariate multinomial distributions</p><pre class="codeinput"><span class="comment">% The multivariate multinomial distribution (_mvmn_) is appropriate for</span>
<span class="comment">% categorical features</span>
<span class="comment">% Train the classifier</span>
<span class="comment">% % % % Nb = NaiveBayes.fit(Xtrain,Ytrain);</span>
<span class="comment">% % % %</span>
<span class="comment">% % % % Make a prediction for the test set</span>
<span class="comment">% % % % Y_Nb = Nb.predict(Xtest);</span>
<span class="comment">% % % %</span>
<span class="comment">% % % % Compute the confusion matrix</span>
<span class="comment">% % % % C_nb = confusionmat(categorical(Ytest),categorical(Y_Nb));</span>
<span class="comment">% % % % Examine the confusion matrix for each class as a percentage of the true class</span>
<span class="comment">% % % % C_nb = bsxfun(@rdivide,C_nb,sum(C_nb,2)) * 100</span>
</pre><h2>Support Vector Machines<a name="9"></a></h2><p>Support vector machine (SVM) is supported for binary response variables. An SVM classifies data by finding the best hyperplane that separates all data points of one class from those of the other class.</p><pre class="codeinput"><span class="comment">% % % % % % opts = statset('MaxIter',30000);</span>
<span class="comment">% % % % % % % Train the classifier</span>
<span class="comment">% % % % % % svmStruct = svmtrain(Xtrain,Ytrain,'kernel_function','rbf','kktviolationlevel',0.1,'options',opts);</span>
<span class="comment">% % % % % %</span>
<span class="comment">% % % % % % % Make a prediction for the test set</span>
<span class="comment">% % % % % % Y_svm = svmclassify(svmStruct,Xtest);</span>
<span class="comment">% % % % % % C_svm = confusionmat(categorical(Ytest),categorical(Y_svm));</span>
<span class="comment">% % % % % % % Examine the confusion matrix for each class as a percentage of the true class</span>
<span class="comment">% % % % % % C_svm = bsxfun(@rdivide,C_svm,sum(C_svm,2)) * 100</span>
</pre><h2>Decision Trees<a name="10"></a></h2><p>Classification trees and regression trees are two kinds of decision trees. A decision tree is a flow-chart like structure in which internal node represents test on an attribute, each branch represents outcome of test and each leaf node represents a response (decision taken after computing all attributes). Classification trees give responses that are nominal, such as 'true' or 'false'. Regression trees give numeric responses.</p><pre class="codeinput">tic
<span class="comment">% Train the classifier</span>
t = ClassificationTree.fit(Xtrain,Ytrain);
toc

<span class="comment">% Make a prediction for the test set</span>
Y_t = t.predict(Xtest);

<span class="comment">% Compute the confusion matrix</span>
C_t = confusionmat(categorical(Ytest),categorical(Y_t));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_t = bsxfun(@rdivide,C_t,sum(C_t,2)) * 100
</pre><pre class="codeoutput">Elapsed time is 0.268380 seconds.

C_t =

  Columns 1 through 7

   99.9774    0.0226         0         0         0         0         0
    0.4930   82.8596    7.3666         0    7.0476    0.0870    0.0290
         0   11.2635   88.6386         0    0.0490         0         0
         0         0         0         0         0  100.0000         0
         0   12.0612         0         0   81.4131    5.5806         0
         0         0         0         0    6.8757   93.0143    0.1100
         0    1.0336    0.5168    0.3876    1.4212    0.3876   95.4780
         0   37.5969    1.1628         0    5.4264    1.5504    3.4884

  Column 8

         0
    2.1172
    0.0490
         0
    0.9451
         0
    0.7752
   50.7752

</pre><h2>Ensemble Learning: TreeBagger<a name="11"></a></h2><p>Bagging stands for bootstrap aggregation. Every tree in the ensemble is grown on an independently drawn sample of input data. To compute prediction for the ensemble of trees, TreeBagger takes an average of predictions from individual trees (for regression) or takes votes from individual trees (for classification). Ensemble techniques such as bagging combine many weak learners to produce a strong learner.</p><p>From a marketing perspective, as we are creating this predictive model, it may be more important for us to classify <b><i>yes</i></b> correctly than a <b><i>no</i></b>. If that is the case, we can include our opinion using the <i>cost</i> matrix. Here, <i>cost</i> matrix specifies that it is 5 times more costly to classify a <b><i>yes</i></b> as a <b><i>no</i></b>.</p><pre class="codeinput"><span class="comment">%opts = statset('UseParallel',true);</span>
<span class="comment">% Train the classifier</span>
tb = TreeBagger(150,Xtrain,Ytrain,<span class="string">'method'</span>,<span class="string">'classification'</span>,<span class="string">'OOBVarImp'</span>,<span class="string">'on'</span>);

<span class="comment">% Make a prediction for the test set</span>
[Y_tb, classifScore] = tb.predict(Xtest);

<span class="comment">% Compute the confusion matrix</span>
C_tb = confusionmat(categorical(Ytest),categorical(Y_tb));
<span class="comment">% Examine the confusion matrix for each class as a percentage of the true class</span>
C_tb = bsxfun(@rdivide,C_tb,sum(C_tb,2)) * 100

<span class="comment">% %% Compare Results</span>
<span class="comment">% % This visualization function is making use of a couple files downloaded</span>
<span class="comment">% % from &lt;http://www.mathworks.com/matlabcentral/ MATLAB Central&gt;, the user</span>
<span class="comment">% % community websibte. We are leveraging social computing along the way to</span>
<span class="comment">% % help us in our effort.</span>
<span class="comment">%</span>
<span class="comment">%Cmat = [C_nn C_glm C_da C_knn C_nb C_svm C_t C_tb];</span>

Cmat = [C_da C_knn C_t C_tb];
labels = {<span class="string">'Discriminant Analysis '</span>,<span class="string">'k-nearest Neighbors '</span>, <span class="string">'Decision Trees'</span>, <span class="string">'TreeBagger'</span>};
disp(<span class="string">'Discriminant Analysis'</span>);
disp(C_da);
disp(<span class="string">'k-nearest Neighbors'</span>);
disp(C_knn);
disp(<span class="string">'Decision Trees'</span>);
disp(C_t);
disp(<span class="string">'TreeBagger'</span>);
disp(C_tb);

<span class="comment">% comparisonPlot(Cmat,labels )</span>

<span class="comment">%</span>
</pre><pre class="codeoutput">
C_tb =

  Columns 1 through 7

  100.0000         0         0         0         0         0         0
    0.5220   90.2552    6.2355         0    1.9432    0.1160         0
         0   15.6219   84.3781         0         0         0         0
         0         0         0         0   50.0000   50.0000         0
         0   19.6220         0         0   76.5527    3.8254         0
         0         0         0         0    8.6909   91.3091         0
         0    1.6796    0.3876         0    1.2920    0.5168   95.6072
         0   52.3256         0         0    3.1008    4.6512    0.3876

  Column 8

         0
    0.9281
         0
         0
         0
         0
    0.5168
   39.5349

Discriminant Analysis
  Columns 1 through 7

   96.4156    0.0791    0.8367         0    1.9222    0.4636         0
    0.4640   99.2749    0.0290         0         0    0.0290         0
         0  100.0000         0         0         0         0         0
         0  100.0000         0         0         0         0         0
         0   99.4599         0    0.0900         0         0    0.4500
         0  100.0000         0         0         0         0         0
         0    5.0388         0    0.2584         0         0   94.4444
         0   94.5736         0         0         0    0.3876    0.3876

  Column 8

    0.2827
    0.2030
         0
         0
         0
         0
    0.2584
    4.6512

k-nearest Neighbors
  Columns 1 through 7

   99.8417    0.1583         0         0         0         0         0
    0.4640   79.2053    8.0046         0    9.1067    0.1450    0.1160
         0   12.9775   86.9246         0    0.0490         0         0
         0         0         0   50.0000   50.0000         0         0
         0   12.7363         0    0.1350   77.5428    7.5158    0.2700
         0    0.6601         0         0    8.3058   90.9241    0.1100
         0    1.6796    0.1292    0.3876    0.7752    0.2584   95.4780
    0.3876   36.0465    1.9380         0    6.9767    1.5504    1.1628

  Column 8

         0
    2.9582
    0.0490
         0
    1.8002
         0
    1.2920
   51.9380

Decision Trees
  Columns 1 through 7

   99.9774    0.0226         0         0         0         0         0
    0.4930   82.8596    7.3666         0    7.0476    0.0870    0.0290
         0   11.2635   88.6386         0    0.0490         0         0
         0         0         0         0         0  100.0000         0
         0   12.0612         0         0   81.4131    5.5806         0
         0         0         0         0    6.8757   93.0143    0.1100
         0    1.0336    0.5168    0.3876    1.4212    0.3876   95.4780
         0   37.5969    1.1628         0    5.4264    1.5504    3.4884

  Column 8

         0
    2.1172
    0.0490
         0
    0.9451
         0
    0.7752
   50.7752

TreeBagger
  Columns 1 through 7

  100.0000         0         0         0         0         0         0
    0.5220   90.2552    6.2355         0    1.9432    0.1160         0
         0   15.6219   84.3781         0         0         0         0
         0         0         0         0   50.0000   50.0000         0
         0   19.6220         0         0   76.5527    3.8254         0
         0         0         0         0    8.6909   91.3091         0
         0    1.6796    0.3876         0    1.2920    0.5168   95.6072
         0   52.3256         0         0    3.1008    4.6512    0.3876

  Column 8

         0
    0.9281
         0
         0
         0
         0
    0.5168
   39.5349

</pre><h2>Simplify Model - Optional<a name="12"></a></h2><p>One may choose to examine the models further. One may even be able to improve the performance of the models. It is also possible to estimate importance of the different features, reduce the dimensionality of feature set etc.</p><h2>Estimating a Good Ensemble Size : learning curve<a name="13"></a></h2><p>Examining the out-of-bag error may give an insight into determining a good ensemble size.</p><pre class="codeinput">figure;
plot(oobError(tb));
xlabel(<span class="string">'Number of Grown Trees'</span>);
ylabel(<span class="string">'Out-of-Bag Classification Error/Misclassification Probability'</span>);
</pre><img vspace="5" hspace="5" src="page_type_classifier_multiple_learning_02.png" alt=""> <h2>Estimating Feature Importance<a name="14"></a></h2><p>Feature importance measures the increase in prediction error if the values of that variable are permuted across the out-of-bag observations. This measure is computed for every tree, then averaged over the entire ensemble and divided by the standard deviation over the entire ensemble.</p><pre class="codeinput">figure;
bar(tb.OOBPermutedVarDeltaError);
ylabel(<span class="string">'Out-Of-Bag Feature Importance'</span>);
set(gca,<span class="string">'XTick'</span>,1:16)
<span class="comment">% names2 = names;</span>
<span class="comment">% names2{5} = ' default';</span>
<span class="comment">% set(gca,'XTickLabel',names2)</span>
<span class="comment">% Use file submitted from a user at MATLAB Central to rotate labels</span>
<span class="comment">%rotateXLabels( gca, 60 )</span>
[~,idxvarimp] = sort(tb.OOBPermutedVarDeltaError, <span class="string">'descend'</span>);
</pre><img vspace="5" hspace="5" src="page_type_classifier_multiple_learning_03.png" alt=""> <h2>Sequential Feature Selection<a name="15"></a></h2><p>Feature selection reduces the dimensionality of data by selecting only a subset of measured features (predictor variables) to create a model. Selection criteria involves the minimization of a specific measure of predictive error for models fit to different subsets.</p><p>Sequential feature selection can be computationally intensive. It can benefit significantly from parallel computing.</p><pre class="codeinput">opts = statset(<span class="string">'display'</span>,<span class="string">'iter'</span>);
opts = statset(opts,<span class="string">'UseParallel'</span>,true);
critfun = @(Xtr,Ytr,Xte,Yte)featureTypeImp(Xtr,Ytr,Xte,Yte,<span class="string">'TreeBagger'</span>);
<span class="comment">% The top 5 features determined in the previous step have been included,</span>
<span class="comment">% to reduce the number of combinations to be tried by sequentialfs*</span>
<span class="comment">% we here keep just 5 predictors</span>
<span class="comment">%[fs,history] = sequentialfs(critfun,Xtrain,Ytrain,'options',opts,'keepin',idxvarimp(1:5));</span>
<span class="comment">%</span>
[fs,history] = sequentialfs(critfun,Xtrain,Ytrain,<span class="string">'options'</span>,opts);<span class="comment">%,'keepin',idxvarimp(1:5));</span>
disp(<span class="string">'Included features:'</span>);
disp(catPred(fs)');
disp([<span class="string">'Percentage of predictors kept : '</span> num2str(sum(fs)./length(fs)*100) <span class="string">'%'</span>]);
</pre><pre class="codeoutput">Starting parallel pool (parpool) using the 'local' profile ... connected to 4 workers.
Start forward sequential feature selection:
Initial columns included:  none
Columns that can not be included:  none
Step 1, added column 1, criterion value NaN
Step 2, added column 2, criterion value NaN
Step 3, added column 3, criterion value NaN
Step 4, added column 4, criterion value NaN
Step 5, added column 5, criterion value NaN
Step 6, added column 6, criterion value NaN
Step 7, added column 7, criterion value NaN
Step 8, added column 8, criterion value NaN
Step 9, added column 9, criterion value NaN
Step 10, added column 10, criterion value NaN
Step 11, added column 11, criterion value NaN
Final columns included:  all
Included features:
    'depth'
    'outlinks_size'
    'inlinks_size'
    'nb_breadcrumbs'
    'nb_aggregated_ratings'
    'nb_ratings_values'
    'nb_prices'
    'nb_availabilities'
    'nb_reviews'
    'nb_reviews_count'
    'nb_images'

Percentage of predictors kept : 100%
</pre><h2>TreeBagger with Reduced Feature Set<a name="16"></a></h2><pre class="codeinput">opts = statset(<span class="string">'UseParallel'</span>,true);
tb_r = TreeBagger(120, Xtrain(:,fs),Ytrain,<span class="string">'method'</span>,<span class="string">'classification'</span>,<span class="string">'PredictorNames'</span>,catPred(:,fs),<span class="string">'Options'</span>,opts);
[Y_tb_r, classifScore] = tb_r.predict(Xtest(:,fs));
Y_tb_r=double(categorical(Y_tb_r))-1;
C_tb_r = confusionmat(categorical(Ytest),categorical(Y_tb_r));
C_tb_r = bsxfun(@rdivide,C_tb_r,sum(C_tb_r,2)) * 100
</pre><pre class="codeoutput">
C_tb_r =

  Columns 1 through 7

         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
         0         0         0         0         0         0         0
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN

  Columns 8 through 14

         0   99.9774    0.0226         0         0         0         0
         0    0.4930   90.1972    6.2645         0    1.9722    0.1450
         0         0   15.8668   84.1332         0         0         0
         0         0         0         0         0   50.0000   50.0000
         0         0   20.0270         0         0   75.8776    4.0954
         0         0         0         0         0    8.4158   91.5842
         0         0    1.8088    0.3876    0.2584    0.9044    0.7752
         0         0   51.5504         0         0    3.4884    2.7132
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN
       NaN       NaN       NaN       NaN       NaN       NaN       NaN

  Columns 15 through 16

         0         0
         0    0.9281
         0         0
         0         0
         0         0
         0         0
   95.4780    0.3876
    0.7752   41.4729
       NaN       NaN
       NaN       NaN
       NaN       NaN
       NaN       NaN
       NaN       NaN
       NaN       NaN
       NaN       NaN
       NaN       NaN

</pre><h2>Compare Results<a name="17"></a></h2><p>Cmat = [C_nn C_glm C_da C_knn C_nb C_svm C_t C_tb C_tb_r]; labels = {'Neural Net ', 'Logistic Regression ', 'Discriminant Analysis ',...     'k-nearest Neighbors ', 'Naive Bayes ', 'Support VM ', 'Decision Trees ', 'TreeBagger ', 'Reduced TB '};</p><p>comparisonPlot( Cmat, labels )</p><h2>Shut Down Workers<a name="18"></a></h2><p>Release the workers if there is no more work for them</p><pre class="codeinput"><span class="comment">% if matlabpool('size') &gt; 0</span>
<span class="comment">%     matlabpool close</span>
<span class="comment">% end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Machine Learning for e-commerce web page page type classification
% Implementing and comparing different machine learning techniques to
% choose the best approach can be challenging. Machine learning is
% synonymous with *Non-parametric* modeling techniques. The term
% non-parametric is not meant to imply that such models completely lack
% parameters but that the number and nature of the parameters are flexible
% and determined from data.

%% Loading data
load('shallow_crawl_cdiscount.mat');
disp(catPred);

%% Cross Validation
% Cross validation is almost an inherent part of machine learning. Cross
% validation may be used to compare the performance of different predictive
% modeling techniques. In this example, we use holdout validation. Other
% techniques including k-fold and leave-one-out cross validation are also
% available.
% 
% In this example, we partition the data into training set and test set.
% The training set will be used to calibrate/train the model parameters.
% The trained model is then used to make a prediction on the test set.
% Predicted values will be compared with actual data to compute the
% confusion matrix. Confusion matrix is one way to visualize the
% performance of a machine learning technique.

% In this example, we will hold 40% of the data, selected randomly, for
% test phase.
cv = cvpartition(length(Y),'holdout',0.40);

% Training set
Xtrain = X(training(cv),:);
Ytrain = Y(training(cv),:);
% Test set
Xtest = X(test(cv),:);
Ytest = Y(test(cv),:);

disp('Training Set')
tabulate(Ytrain)
disp('Test Set')
tabulate(Ytest)

%% Tree performance on validating and training set 
t = classregtree(Xtrain,Ytrain);
%  See tree
view(t)
% How well did the single tree perform on the training set
% very well but overfit the noise
predY = t(Xtrain);
%predY = round(predY);
disp('Full tree training set')
disp('Full tree training set')
myCategoricalErrorRate(predY,Ytrain);
C_tree = confusionmat(categorical(predY),categorical(Ytrain));
% Examine the confusion matrix for each class as a percentage of the true class
C_tree = bsxfun(@rdivide,C_tree,sum(C_tree,2)) * 100 %#ok<*NOPTS>

% Calculate the single tree's predictions on the validating set...
predY = t(Xtest);
disp('Full tree validating set')
myCategoricalErrorRate(predY,Ytest);
[C_tree, order] = confusionmat(categorical(predY),categorical(Ytest));
% Examine the confusion matrix for each class as a percentage of the true class
C_tree = bsxfun(@rdivide,C_tree,sum(C_tree,2)) * 100 %#ok<*NOPTS>
order

%% Neural Networks
% Neural Network Toolbox supports supervised learning with feedforward,
% radial basis, and dynamic networks. It supports both classification and
% regression algorithms. It also supports unsupervised learning with
% self-organizing maps and competitive layers.
% 
% One can make use of the interactive tools to setup, train and validate a
% neural network. It is then possible to auto-generate the code for the
% purpose of automation. In this example, the auto-generated code has been
% updated to utilize a pool of workers, if available. This is achieved by
% simply setting the _useParallel_ flag while making a call to |train|.
% 
%   [net,~] = train(net,inputs,targets,'useParallel','yes');
% 
% If a GPU is available, it may be utilized by setting the _useGPU_ flag.
% 
% The trained network is used to make a prediction on the test data and
% confusion matrix is generated for comparison with other techniques.

% Use modified autogenerated code to train the network
% % % % % % 
% % % % % % YN = double(Y)-1;
% % % % % % XtrainNN = X(training(cv),:);
% % % % % % YtrainNN = YN(training(cv),:);
% % % % % % Test set
% % % % % % XtestNN = X(test(cv),:);
% % % % % % YtestNN = YN(test(cv),:);
% % % % % % 
% % % % % % 
% % % % % % [XtrainNN, YtrainNN, XtestNN, YtestNN] = preparedataNN(X, Y, cv);
% % % % % % 
% % % % % % [~, net] = NNfun(XtrainNN,YtrainNN);
% % % % % % view(net);
% % % % % % Make a prediction for the test set
% % % % % % Y_nn = net(Xtest');
% % % % % % Y_nn = round(Y_nn');
% % % % % % 
% % % % % % Compute the confusion matrix
% % % % % % C_nn = confusionmat(categorical(Ytest),categorical(Y_nn));
% % % % % % Examine the confusion matrix for each class as a percentage of the true class
% % % % % % C_nn = bsxfun(@rdivide,C_nn,sum(C_nn,2)) * 100 %#ok<*NOPTS>

%% Generalized Linear Model - Logistic Regression
% In this example, a logistic regression model is leveraged. Response may
% follow normal, binomial, Poisson, gamma, or inverse Gaussian
% distribution. 
% 
% Since the response in this data set is binary, binomial distribution is
% suitable.

% Train the classifier
% % % % % % glm = GeneralizedLinearModel.fit(Xtrain,Ytrain,'linear','Distribution','binomial','link','logit');
% % % % % % 
% % % % % % % Make a prediction for the test set
% % % % % % Y_glm = glm.predict(Xtest);
% % % % % % Y_glm = round(Y_glm);
% % % % % % 
% % % % % % % Compute the confusion matrix
% % % % % % C_glm = confusionmat(categorical(Ytest),categorical(Y_glm));
% % % % % % % Examine the confusion matrix for each class as a percentage of the true class
% % % % % % C_glm = bsxfun(@rdivide,C_glm,sum(C_glm,2)) * 100

%% Discriminant Analysis
% Discriminant analysis is a classification method. It assumes that
% different classes generate data based on different Gaussian
% distributions. Linear discriminant analysis is also known as the Fisher
% discriminant. 
% 
% Here, a quadratic discriminant classifier is used.

% Train the classifier
da = ClassificationDiscriminant.fit(Xtrain,Ytrain,'discrimType','pseudoQuadratic');

% Make a prediction for the test set
Y_da = da.predict(Xtest);

% Compute the confusion matrix
C_da = confusionmat(categorical(Ytest),categorical(Y_da));
% Examine the confusion matrix for each class as a percentage of the true class
C_da = bsxfun(@rdivide,C_da,sum(C_da,2)) * 100

%% Classification Using Nearest Neighbors
% Categorizing query points based on their distance to points in a training
% dataset can be a simple yet effective way of classifying new points.
% Various distance metrics such as euclidean, correlation, hamming,
% mahalonobis or your own distance metric may be used.

% Train the classifier
knn = ClassificationKNN.fit(Xtrain,Ytrain,'Distance','seuclidean');

% Make a prediction for the test set
Y_knn = knn.predict(Xtest);

% Compute the confusion matrix
C_knn = confusionmat(categorical(Ytest),categorical(Y_knn));
% Examine the confusion matrix for each class as a percentage of the true class
C_knn = bsxfun(@rdivide,C_knn,sum(C_knn,2)) * 100

%% Naive Bayes Classification
% Naive Bayes classification is based on estimating P(X|Y), the probability
% or probability density of features X given class Y. The Naive Bayes
% classification object provides support for normal (Gaussian), kernel,
% multinomial, and multivariate multinomial distributions

% The multivariate multinomial distribution (_mvmn_) is appropriate for
% categorical features
% Train the classifier
% % % % Nb = NaiveBayes.fit(Xtrain,Ytrain);
% % % % 
% % % % Make a prediction for the test set
% % % % Y_Nb = Nb.predict(Xtest);
% % % % 
% % % % Compute the confusion matrix
% % % % C_nb = confusionmat(categorical(Ytest),categorical(Y_Nb));
% % % % Examine the confusion matrix for each class as a percentage of the true class
% % % % C_nb = bsxfun(@rdivide,C_nb,sum(C_nb,2)) * 100

%% Support Vector Machines
% Support vector machine (SVM) is supported for binary response variables.
% An SVM classifies data by finding the best hyperplane that separates all
% data points of one class from those of the other class.

% % % % % % opts = statset('MaxIter',30000);
% % % % % % % Train the classifier
% % % % % % svmStruct = svmtrain(Xtrain,Ytrain,'kernel_function','rbf','kktviolationlevel',0.1,'options',opts);
% % % % % % 
% % % % % % % Make a prediction for the test set
% % % % % % Y_svm = svmclassify(svmStruct,Xtest);
% % % % % % C_svm = confusionmat(categorical(Ytest),categorical(Y_svm));
% % % % % % % Examine the confusion matrix for each class as a percentage of the true class
% % % % % % C_svm = bsxfun(@rdivide,C_svm,sum(C_svm,2)) * 100

%% Decision Trees
% Classification trees and regression trees are two kinds of decision
% trees. A decision tree is a flow-chart like structure in which internal
% node represents test on an attribute, each branch represents outcome of
% test and each leaf node represents a response (decision taken after
% computing all attributes). Classification trees give responses that are
% nominal, such as 'true' or 'false'. Regression trees give numeric
% responses.

tic
% Train the classifier
t = ClassificationTree.fit(Xtrain,Ytrain);
toc

% Make a prediction for the test set
Y_t = t.predict(Xtest);

% Compute the confusion matrix
C_t = confusionmat(categorical(Ytest),categorical(Y_t));
% Examine the confusion matrix for each class as a percentage of the true class
C_t = bsxfun(@rdivide,C_t,sum(C_t,2)) * 100

%% Ensemble Learning: TreeBagger
% Bagging stands for bootstrap aggregation. Every tree in the ensemble is
% grown on an independently drawn sample of input data. To compute
% prediction for the ensemble of trees, TreeBagger takes an average of
% predictions from individual trees (for regression) or takes votes from
% individual trees (for classification). Ensemble techniques such as
% bagging combine many weak learners to produce a strong learner.
% 
% From a marketing perspective, as we are creating this predictive model,
% it may be more important for us to classify *_yes_* correctly than a
% *_no_*. If that is the case, we can include our opinion using the _cost_
% matrix. Here, _cost_ matrix specifies that it is 5 times more costly to
% classify a *_yes_* as a *_no_*.

%opts = statset('UseParallel',true);
% Train the classifier
tb = TreeBagger(150,Xtrain,Ytrain,'method','classification','OOBVarImp','on');

% Make a prediction for the test set
[Y_tb, classifScore] = tb.predict(Xtest);

% Compute the confusion matrix
C_tb = confusionmat(categorical(Ytest),categorical(Y_tb));
% Examine the confusion matrix for each class as a percentage of the true class
C_tb = bsxfun(@rdivide,C_tb,sum(C_tb,2)) * 100

% %% Compare Results
% % This visualization function is making use of a couple files downloaded
% % from <http://www.mathworks.com/matlabcentral/ MATLAB Central>, the user
% % community websibte. We are leveraging social computing along the way to
% % help us in our effort.
% 
%Cmat = [C_nn C_glm C_da C_knn C_nb C_svm C_t C_tb];

Cmat = [C_da C_knn C_t C_tb];
labels = {'Discriminant Analysis ','k-nearest Neighbors ', 'Decision Trees', 'TreeBagger'};
disp('Discriminant Analysis');
disp(C_da);
disp('k-nearest Neighbors');
disp(C_knn);
disp('Decision Trees');
disp(C_t);
disp('TreeBagger');
disp(C_tb);

% comparisonPlot(Cmat,labels )

% 
%% Simplify Model - Optional
% One may choose to examine the models further. One may even be able to
% improve the performance of the models. It is also possible to estimate
% importance of the different features, reduce the dimensionality of
% feature set etc.

%% Estimating a Good Ensemble Size : learning curve
% Examining the out-of-bag error may give an insight into determining a
% good ensemble size. 

figure;
plot(oobError(tb));
xlabel('Number of Grown Trees');
ylabel('Out-of-Bag Classification Error/Misclassification Probability');

%% Estimating Feature Importance
% Feature importance measures the increase in prediction error if the
% values of that variable are permuted across the out-of-bag observations.
% This measure is computed for every tree, then averaged over the entire
% ensemble and divided by the standard deviation over the entire ensemble.

figure;
bar(tb.OOBPermutedVarDeltaError);
ylabel('Out-Of-Bag Feature Importance');
set(gca,'XTick',1:16)
% names2 = names;
% names2{5} = ' default';
% set(gca,'XTickLabel',names2)
% Use file submitted from a user at MATLAB Central to rotate labels
%rotateXLabels( gca, 60 )
[~,idxvarimp] = sort(tb.OOBPermutedVarDeltaError, 'descend');

%% Sequential Feature Selection
% Feature selection reduces the dimensionality of data by selecting only a
% subset of measured features (predictor variables) to create a model.
% Selection criteria involves the minimization of a specific measure of
% predictive error for models fit to different subsets.
% 
% Sequential feature selection can be computationally intensive. It can
% benefit significantly from parallel computing.
opts = statset('display','iter');
opts = statset(opts,'UseParallel',true);
critfun = @(Xtr,Ytr,Xte,Yte)featureTypeImp(Xtr,Ytr,Xte,Yte,'TreeBagger');
% The top 5 features determined in the previous step have been included,
% to reduce the number of combinations to be tried by sequentialfs*
% we here keep just 5 predictors
%[fs,history] = sequentialfs(critfun,Xtrain,Ytrain,'options',opts,'keepin',idxvarimp(1:5));
%
[fs,history] = sequentialfs(critfun,Xtrain,Ytrain,'options',opts);%,'keepin',idxvarimp(1:5));
disp('Included features:');
disp(catPred(fs)');
disp(['Percentage of predictors kept : ' num2str(sum(fs)./length(fs)*100) '%']);


%% TreeBagger with Reduced Feature Set

opts = statset('UseParallel',true);
tb_r = TreeBagger(120, Xtrain(:,fs),Ytrain,'method','classification','PredictorNames',catPred(:,fs),'Options',opts);
[Y_tb_r, classifScore] = tb_r.predict(Xtest(:,fs));
Y_tb_r=double(categorical(Y_tb_r))-1;
C_tb_r = confusionmat(categorical(Ytest),categorical(Y_tb_r));
C_tb_r = bsxfun(@rdivide,C_tb_r,sum(C_tb_r,2)) * 100

%% Compare Results
% 
% Cmat = [C_nn C_glm C_da C_knn C_nb C_svm C_t C_tb C_tb_r];
% labels = {'Neural Net ', 'Logistic Regression ', 'Discriminant Analysis ',...
%     'k-nearest Neighbors ', 'Naive Bayes ', 'Support VM ', 'Decision Trees ', 'TreeBagger ', 'Reduced TB '};
% 
% comparisonPlot( Cmat, labels )


%% Shut Down Workers
% Release the workers if there is no more work for them

% if matlabpool('size') > 0
%     matlabpool close
% end

##### SOURCE END #####
--></body></html>